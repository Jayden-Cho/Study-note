# Unit 04 기본 문자열 함수 이해하기

> 텍스트 문자열을 읽고 변형하는 방법 배우기

문자열 - 컴퓨터와 인간 세계를 잇는 상호 작용의 기본 단위.

- 대부분의 원천 데이터는 문자열 형태로 저장됨.

<br>

**대, 소문자 변환(case conversion) 함수**는 문자열 s의 복사본을 반환한다. 

- `lower()`, `upper()` 함수는 각각 문자를 소문자, 대문자를 변환한다.
- `capitalize()` 함수는 첫 번째 문자를 대문자로 변환하고, 나머지 문자들은 소문자로 변환한다.
- 위 함수들 모두 알파벳이 아닌 문자는 무시한다.

<br>

**프레디케이트(predicate) 함수**는 문자열 s가 특정 클래스에 속하는지에 따라 True, False를 반환한다. 이 함수들을 통해 단어가 정확한지, 정수가 양수인지, 띄어쓰기가 올바른지 등을 테스트할 수 있다.

> predicate?
>
> **술부**(John went home에서 went home처럼, 문장 속에서 주어에 대해 진술하는 동사 이하 부분).
>
> 여기서는 True/False를 반환하는 함수로 해석된다.

- `islower()` , `isupper()` 함수는 각각  모든 알파벳 문자가 소문자, 대문자인지 체크한다.
- `isspace()` 함수는 모든 문자가 공백인지 체크한다.
- `isdigit()` 함수는 모든 문자가 0에서 9 사이 숫자인지 확인한다.
- `isalpha()` 함수는 모든 문자가 a~z, A~Z 사이의 알파벳 문자인지 체크한다. 

<br>

외부 파일이나 DB, 웹에서 데이터를 가져왔다면 때때로 파이썬은 문자열 데이터를 문자열이 아닌 <u>바이너리 배열</u>로 표현한다.

- 파이썬에서는 바이너리 배열 앞에 b를 붙여서 표기한다. 

~~~python
bin = b"Hello" # 바이너리 배열
print(bin[0])
s = "Hello" # 문자열
print(s[0])

# result: 
# 72
# 0
~~~

- '72'는 문자 'H'에 해당하는 ASCII 문자코드(charcode)다.

디코딩(decoding) 함수는 바이너리 배열을 문자열로 변환한다. 많은 파이썬 함수는 <u>문자열로 변환된 상태의 바이너리 데이터</u>를 처리한다 (decoding이 중요하다).

- `bin.decode()` 는 바이너리 배열을 문자열로 변환한다.
- `s.encode()` 는 문자열을 바이너리 배열로 변환한다.

<br>

문자열 처리의 첫 번째 단계는 원치 않는 공백(새로운 줄과 탭을 포함)을 제거하는 것.

- `lstrip()`, `rstrip()`, `strip()` 함수들은 문자열의 공백을 제거한다.
  - 문자 사이의 공백은 제거하지 않는다.

~~~python
s = "Hello, world! \t\t\n"
print(s)
s = s.strip()
print(s)

# result:
# Hello, world! 		

# Hello, world!
~~~

<br>

split(delim="")` 함수는 delim을 구분자로 사용해 문자열 s를 부분 문자열의 리스트로 쪼갠다.

- 구분자가 지정되지 않았다면 공백을 사용하고, 연속해서 공백이 있으면 하나의 공백으로 인식한다.

자매 함수인 `join(ls)` 는 객체 문자열을 접착제로 사용해 문자열 리스트 ls를 하나의 문자열로 붙인다.

- `join()` 함수를 사용하면 문자열 조각을 재조합할 수 있다.

~~~python
ls = ["A", "B", "C", "D"]
ls_join = ",".join(ls)
print(ls)
print(ls_join)

# result:
# ['A', 'B', 'C', 'D']
# A,B,C,D
~~~

<br>

문자열을 자르고 다시 합치는 것은 구분자를 다른 문자열로 치환하는 것과 같다.

~~~python
strNum = "1.617.205.1985"
print(strNum) # 1.617.205.1985
sN_split = strNum.split(".")
print(sN_split) # ['1', '617', '205', '1985']
sN_final = "-".join(strNum.split("."))
print(sN_final) # 1-617-205-1985
~~~

<br>

정규 표현식에 기반한 치환을 사용하면 필요 없는 공백을 문자열에서 제거할 수 있다.

~~~python
s = 'This string\n\r has many\t\tspaces'
print(s)
s = s.split()
print(s)
s = " ".join(s)
print(s)

# This string
#  has many		 spaces
# ['This', 'string', 'has', 'many', 'spaces']
# This string has many spaces
~~~

<br>

`find(needle)` 함수는 해당 문자열에서 부분 문자열 needle이 처음 등장하는 인덱스를 반환.

- 부분 문자열이 없을 때는 -1을 반환. 대, 소문자를 구분(case-sensitive).
- 문자열에서 특히 관심 있는 부분을 찾을 때 `find()` 함수를 활용할 수 있다.

~~~python
"www.networksciencelab.com".find(".com")
# 21
~~~

<br>

`count(needle)` 함수는 대상 문자열에서 부분 문자열 needle이 등장하는 횟수를 반환.

- 역시 case-sensitive.

~~~python
"www.networksciencelab.com".count(".")
# 2
~~~

<br>

# Unit 05 올바른 자료구조 선택하기

> 파이썬에서 가장 빈번하게 사용하는 자료구조는 리스트, 튜플, 셋, 딕셔너리. 모두 데이터의 **컬렉션**이다.

<br>

파이썬은 리스트를 배열처럼 취급한다. 튜플은 변형이 불가능한 리스트다. 셋(set)에는 순서와 인덱스가 없다.

- 리스트나 튜플에서 아이템을 검색할 때 걸리는 시간은 선형적으로 증가.
  - 검색이 가능한 대용량의 데이터는 저장하는 용도로는 실용성이 떨어진다.

- 셋에서는 같은 아이템이 중복으로 저장될 수 없다.
  - 검색 시간은 준선형적인 O(log(N))으로 증가한다. 회원 명단을 조회하거나 중복 항목을 삭제하는데 셋을 사용할 수 있다.
- 중복된 아이템이 들어있는 리스트를 셋으로 변환하면 중복된 아이템을 모두 삭제한다.

~~~python
myList = list(set(myList)) # myList에서 중복된 아이템들을 삭제한다.
~~~

<br>

리스트 데이터를 셋으로 변환해 더 빠르게 아이템을 찾아보자.

~~~python
bigList = [str(i) for i in range(10000000)]
"abc" in bigList

bigSet = set(bigList)
"abc" in bigSet
~~~

- 리스트보다 셋의 속도가 훨씬 빠르다.

<br>

딕셔너리는 키(key)를 값(value)에 매핑한다.

- 숫자, 불(boolean), 문자열, 튜플처럼 해시화할 수 있는 데이터 타입은 키가 될 수 있다. 
  - 같은 딕셔너리에 들어있다 해도 서로 다른 데이터 타입이 속할 수 있다.
  - 검색 시간은 준선형적인 O(log(N))으로 증가한다.

> 해시화?
>
> 원래 데이터를 수학적 함수로 계산하여 다른 값으로 변환하는 처리 방법.

- 튜플(키, 값)이 여러 개 있는 리스트에서 딕셔너리를 만들 수 있다.
- 내장 클래스 생성자 `enumerate(seq)` 를 사용해 seq 안의 아이템 순번을 키로 지정한 딕셔너리를 만들 수 있다.

~~~Python
seq = ["A", "B", "C", "D"]
dict(enumerate(seq))

# result:
# {0: 'A', 1: 'B', 2: 'C', 3: 'D'}
~~~

<br>

키 순서열(kseq)과 값 순서열(vseq)에 클래스 생성자인 `zip(kseq, vseq)`를 사용할수도 있다.

~~~python 
kseq = 'abcd' # 문자열 또한 순서열이다.
vseq = ["A", "B", "C", "D"]
dict(zip(kseq, vseq))

# result:
# {'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D'}
~~~

<br>

파이썬에서 `enumerate(seq)`와 `zip(kseq, vseq)` 함수는 리스트 제너레이터(generator)로 사용한다.

- 리스트 제너레이터는 이터레이터(iterator) 인터페이스를 제공해 for 루프를 사용 가능하게 한다.
- 제너레이터는 요청이 있을 때만(`list()`와 같은) 아이템을 생산하는 지연 방식(lazy way)으로 작동한다.
  - 제너레이터는 대용량의 리스트를 소화할 수 있고, 무한 리스트도 허용한다.
  - `list()` 함수를 사용해 제너레이터를 리스트로 명시적으로 변환할 수 있다.

<br>

# Unit 06 리스트 내포로 리스트 이해하기

> 리스트 내포(List comprehension)는 컬렉션을 리스트(나 다른 자료형)로 변환하는 표현식. 같은 연산을 리스트의 전체나 일부 아이템에 적용할 수 있다.

<br>

전체 변환 과정

1. 리스트 내포 표현식이 컬렉션을 순회하고, 컬렉션 안 아이템을 조회한다.
2. 각 아이템에 불 표현식을 적용해 True면 아이템에 표현식을 적용하고, False면 해당 아이템은 무시한다.
3. True로 출력된 값을 리스트에 추가한다.

간단한 리스트 내포 예제

~~~python
# myList를 복사한다. 비효율적인 방식.
[x for x in myList]

# 음수가 아닌 항목만 추린다.
[x for x in myList if x >= 0]

# 모든 아이템을 거듭제곱한다.
[x**2 for x in myList]

# 0이 아닌 아이템의 역수를 취한다.
[1/x for x in myList if x!=0]

# infile 파일에서 비어 있지 않은 줄을 읽어 와서 문장 앞과 뒤의 공백을 지운다.
[l.strip() for l in infile if l.strip()]
~~~

<br>

마지막 예제에서 `strip()` 함수를 중복 사용하는 걸 원하지 않으면 중첩된 리스트 내포(nested list comprehension)을 활용.

~~~python
# 안쪽 리스트 내포는 공백을 지우고, 바깥쪽 리스트 내포는 빈 문자열을 지운다.
[line for line in [l.strip() for l in infile] if line]
~~~

<br>

리스트 내포를 대괄호가 아닌 소괄호로 묶으면 리스트 제너레이터 객체로 인식한다.

~~~python
(x**2 for x in myList)
# result: 
# <generator object <genexpr> at 0x10ef26f50>
~~~

<br>

때때로 리스트 내포의 결과물은 숫자나 단어, 형태소, 표제어 등 반복되는 아이템의 리스트가 된다.

- 이 중 가장 빈번하거나 희귀한 아이템이 어떤 것인지 찾고 싶으면 **카운터 클래스**를 사용하면 된다.

<br>

# Unit 07 카운터로 세기

> 카운터(counter)는 딕셔너리 스타일의 컬렉션으로 다른 컬렉션 안의 아이템 개수를 셀 때 사용한다.

<br>

카운터는 `collections` 모듈 안에 정의되어 있다.

- 취합할 컬렉션을 Counter 생성자로 전달하고,  `most_common(n)` 함수를 사용해 가장 빈번하게 등장한 n개의 아이템과 그 빈도가 담긴 리스트를 얻을 수 있다.

~~~python
from collections import Counter
phrase = "a man a plan a canal panama"
# 취합할 컬렉션을 Counter 생성자로 전달.
cntr = Counter(phrase.split())
# most_common(n) 함수 사용.
cntr.most_common()

# result: 
# [('a', 3), ('man', 1), ('plan', 1), ('canal', 1), ('panama', 1)]
~~~

<br>

출력된 리스트를 딕셔너리로 변환하면 가독성이 좋아진다.

~~~python
cntrDict = dict(cntr.most_common())
cntrDict
# result: 
# {'a': 3, 'man': 1, 'plan': 1, 'canal': 1, 'panama': 1}
~~~

